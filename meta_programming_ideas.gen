
// compile-time commands start with @
// a type variable can be transformed into a type specifier using $t ???
// -> maybe not required, as we have a single name registry for types and variables anyway
// -> we may want to change this, it would make sense to have a size member as well as a size member function


@if (X64) {
    @inject getFragment(); // injects code fragment generated by getFragment()
}

@getFragment :: () -> fragment { // starting with @ means it may only be called at compile-time
    list :: { {"x", 1}, {"y", 2}, {"z", 3} };
    for [x, t] in list {
        @generate { $x := $t }
    }
}

@addClone :: (T : Type*) {
    clone := fragment () -> (result : $T) {};
    // member variable modification may not be allowed via extend
    // -> we need the type declaration to contain all member variables and generators thereof
    for mem : T.memberVariables() {
        @extend(clone) { result.$mem = this.$mem; }
    }
    @extend(T) { @inject $clone; }
}

Test :: struct {
    a := 0;
    b := "";
}

@addClone(Test);

printf("x: %d; y: %d; z: %d\n", x, y, z);
